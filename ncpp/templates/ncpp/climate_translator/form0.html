<!-- Form to select the dataset -->

<!-- YUI libraries -->
<script src="http://yui.yahooapis.com/2.9.0/build/yahoo/yahoo-min.js"></script>
<script src="http://yui.yahooapis.com/2.9.0/build/event/event-min.js"></script>
<script src="http://yui.yahooapis.com/2.9.0/build/connection/connection_core-min.js"></script>

<!-- custom javascript code -->
<script language="javascript">

	// widget ids as set by Django wizard
    var WIDGET_DATA_TYPE = "id_0-data_type"
    var WIDGET_VARIABLE = "id_0-variable";
    var WIDGET_TIME_FREQUENCY = "id_0-frequency";
    var WIDGET_DATASET_CATEGORY = "id_0-dataset_category";
    var WIDGET_DATASET = "id_0-dataset";
    var NULL_SELECTION = ["","-- Please Select --"]

    // function triggered by a change in data type selection
    function getDatasets() {
    	
    	dataType = document.getElementById(WIDGET_DATA_TYPE).value;
    	if (dataType==null || dataType=='') {
    		
  	        var options = new Array(NULL_SELECTION);
  	        showOptions(WIDGET_VARIABLE, options, []);
  	        showOptions(WIDGET_TIME_FREQUENCY, options, []);
  	      	showOptions(WIDGET_DATASET_CATEGORY, options, []);
  	    	showOptions(WIDGET_DATASET, options, []);
    		
    	} else {
  		    			
  		      // data_type is selected
  		      url = '/ncpp/climate_translator/datasets'
  		          + '?data_type='+encodeURIComponent(dataType);
  		      
  		      // variable 'long_name' is selected
  		      variable = document.getElementById(WIDGET_VARIABLE).value;
  		      if (variable!=null && variable!='') url += "&variable="+encodeURIComponent(variable);
  		      
  		      // time_frequency is selected
  		      time_frequency = document.getElementById(WIDGET_TIME_FREQUENCY).value;
  		      if (time_frequency!=null && time_frequency!='') url += "&time_frequency="+encodeURIComponent(time_frequency);

  		      // dataset_category is selected
  		      dataset_category = document.getElementById(WIDGET_DATASET_CATEGORY).value;
  		      if (dataset_category!=null && dataset_category!='') url += "&dataset_category="+encodeURIComponent(dataset_category);

  		      // dataset is selected
  		      dataset = document.getElementById(WIDGET_DATASET).value;
  		      if (dataset!=null && dataset!='') url += "&dataset="+encodeURIComponent(dataset);
  		    	  
			  // execute async request
  		      var transaction = YAHOO.util.Connect.asyncRequest('GET', url, ajaxDatasetsCallback, null);   			
 
    	}
    	
    	
    }
    
    // function triggered by a change in variable selection
    function variableSelected() {
    	
    	selectedValue = document.getElementById(WIDGET_VARIABLE).value;
    	
    	if (selectedValue==null || selectedValue=='') {
    		
  	        var options = new Array();
  	        options[0] = ["","-- Please Select --"];
  	        showOptions(WIDGET_TIME_FREQUENCY, options, []);
    		
    	} else {
    		
		      // execute ajax call to retrieve the available geometries
		      url = '/ncpp/climate_translator/datasets'
		          + '?variable='+encodeURIComponent(selectedValue)
		    	  + '&widget_id='+WIDGET_TIME_FREQUENCY;
		      var transaction = YAHOO.util.Connect.asyncRequest('GET', url, ajaxCallback, null);
    		
    	}
    		
    }
    
    // function triggered by a change in time frequency selection
    function frequencySelected() {
    	
    	selectedValue = document.getElementById(WIDGET_TIME_FREQUENCY).value;
    	
    	if (selectedValue==null || selectedValue=='') {
    		
  	        var options = new Array();
  	        options[0] = ["","-- Please Select --"];
  	        showOptions(WIDGET_DATASET, options, []);
    		
    	} else {
    		
    		  alert("GOT THIS FAR");
		      // execute ajax call to retrieve the available geometries
		      url = '/ncpp/climate_translator/datasets'
		          + '?variable='+encodeURIComponent(selectedValue)
		          + '&frequency='
		    	  + '&widget_id='+WIDGET_DATASET;
		      var transaction = YAHOO.util.Connect.asyncRequest('GET', url, ajaxDatasetsCallback, null);
    		
    	}
    	
    	
    }

	// function to populate the form widget with the dataset choices
	function populateDatasetsXXX() {

		// dataset options
		var options = new Array();
		options[0] = ["","-- Please Select --"];
		
		// retrieve current dataset category selection
		datasetCategorySelect = document.getElementById("id_0-dataset_category");
		if (datasetCategorySelect.value!=null && datasetCategorySelect.value!='') {
			
			// FIXME: parse only once ?
			var datasets = JSON.parse("{{datasets}}".unescapeHtml());			
			jsonData = datasets[datasetCategorySelect.value];
			for (var dt in jsonData) {
				options.push( [dt, dt] );
			}
	
		} 
		
		showOptions("id_0-dataset", options, [ "{{wizard.form.dataset.value}}" ]);
		
	}
	
	// function to populate the form widget with the variable choices
	function populateVariables() {

		// variable options
		var options = new Array();
		options[0] = ["","-- Please Select --"];
		
		// retrieve current selection for dataset category  and dataset
		datasetCategorySelect = document.getElementById("id_0-dataset_category");
		datasetSelect = document.getElementById("id_0-dataset");
		if (   datasetCategorySelect.value!=null && datasetCategorySelect.value!='' 
			&& datasetSelect.value!=null && datasetSelect.value!='') {
			
			var datasets = JSON.parse("{{datasets}}".unescapeHtml());			
			jsonData = datasets[datasetCategorySelect.value][datasetSelect.value];
			
			if (jsonData['type']=='datasets') {
				// datasets: must make variable selection
				for (var variable in jsonData) {
					if (variable != 'type') {
						options.push( [variable, variable] )
					}
				}
			} else if (jsonData['type']=='package') {
				
				// package: no variable selection necessary
				options[0] = ["","-- No selection necessary --"];
				
				// but populate date/times from package information
				datetime_start = jsonData["time_range"][0];
				datetime_stop = jsonData["time_range"][1];
				_populateDateTimes(datetime_start, datetime_stop);
			
			}
	
		} 
				
		showOptions("id_0-variable", options, [ "{{wizard.form.variable.value}}" ]);
		
	}
	
	// function to populate the geometry sub-type
	function populateGeometrySubCategories() {
		
		geometryCategorySelect = document.getElementById("id_0-geometry_category");
	    if (geometryCategorySelect.value!=null && geometryCategorySelect.value!='') {
	       
	      // execute ajax call to retrieve the available geometries
	      url = '/ncpp/climate_translator/geometries?category='+encodeURIComponent(geometryCategorySelect.value);
	      var transaction = YAHOO.util.Connect.asyncRequest('GET', url, geometrySubCategoryCallback, null);
	
	    } else {
	      
	      // populate geometry widget with no options
	      var options = new Array();
	      options[0] = ["","-- Please Select --"];
	      showOptions("id_0-geometry_subcategory", options, []);
	      
	    }
		
	}
		
	// function to populate the geometries widget
	function populateGeometryIds() {
		
		geometryCategorySelect = document.getElementById("id_0-geometry_category");
		geometrySubCategorySelect = document.getElementById("id_0-geometry_subcategory");
	    if (   geometryCategorySelect.value!=null && geometryCategorySelect.value!=''
	    	&& geometrySubCategorySelect.value!=null && geometrySubCategorySelect.value!='' ) {
	       
	      // execute ajax call to retrieve the available geometries
	      url = '/ncpp/climate_translator/geometries'
	    	 +  '?category='+encodeURIComponent(geometryCategorySelect.value)
	    	 +  '&subcategory='+encodeURIComponent(geometrySubCategorySelect.value)
	    		                      ;
	      var transaction = YAHOO.util.Connect.asyncRequest('GET', url, geometryIdCallback, null);
	
	    } else {
	      
	      // populate geometry widget with no options
	      var options = new Array();
	      options[0] = ["","-- Please Select --"];
	      showOptions("id_0-geometry_id", options, []);
	      
	    }
	
	}
	
	// function to populate a select widget with options,
	// and maintain any previous selection
	function showOptions(widgetId, options, selectedValues) {

		selectWidget = document.getElementById(widgetId);
		selectWidget.options.length = 0;
		for (var i = 0; i < options.length; i++) {
			var option = new Option(options[i][1], options[i][0]); // label, value
			for (var j=0; j<selectedValues.length; j++) {
				if (options[i][0] == selectedValues[j]) option.selected = true;	
			}
			selectWidget.add( option );
		}
				
	}
		
	// function to populate the start, stop times
	function populateDateTimes() {
			
		// retrieve current selection for dataset category  and dataset
		datasetCategorySelect = document.getElementById("id_0-dataset_category");
		datasetSelect = document.getElementById("id_0-dataset");
		variableSelect = document.getElementById("id_0-variable");
		if (   datasetCategorySelect.value!=null && datasetCategorySelect.value!='' 
			&& datasetSelect.value!=null && datasetSelect.value!=''
			&& variableSelect.value!=null && variableSelect.value!='') {	
			
				var datasets = JSON.parse("{{datasets}}".unescapeHtml());
				jsonData = jsonData = datasets[datasetCategorySelect.value][datasetSelect.value][variableSelect.value]["time_range"];		
				if (jsonData!=null) { // type='datasets'
					_populateDateTimes(jsonData[0], jsonData[1]);
				}
		
		}

	}
	
	// function to populate the start, stop times
	function _populateDateTimes(datetime_start, datetime_stop) {
		startDateTimeText = document.getElementById("id_0-datetime_start");
		startDateTimeText.value = datetime_start;
		stopDateTimeText = document.getElementById("id_0-datetime_stop");
		stopDateTimeText.value = datetime_stop;
	}
	
	// function to populate the geometry choices
	function showGeometries(geometries) {

		var options = new Array();
		for (var i = 0; i < geometries.length; i++) {			
			options.push( [geometries[i][1], geometries[i][0]] );
		}
		// must parse current selection of shapes (a concatenated string) into array of strings
		var selectedValues = new Array();
		var shapes = "{{wizard.form.geometry_id.value}}";
		if (shapes!="None") {
			shapes = shapes.unescapeHtml();
			shapes = shapes.substring(1,shapes.length-1);
			shapes = shapes.split(",");
			for (var i=0; i<shapes.length; i++) {
				// u'Arkansas'
				shape =  shapes[i].trim();
				selectedValues[i] = shape.substring(2, shape.length-1);
			}
		}
		showOptions("id_0-geometry_id", options, selectedValues);

	}
	
	// function to populate the geometry choices
	function showGeometrySubCategories(geometries) {

		var options = new Array();
		for (var i = 0; i < geometries.length; i++) {			
			options.push( [geometries[i][1], geometries[i][0]] );
		}
		showOptions("id_0-geometry_subcategory", options, [ "{{wizard.form.geometry_subcategory.value}}" ]);
		
	}
	
	// function called if Ajax request failed
	var handleFailure = function(o) {
		alert("An Error Occurred!"
		     +"\nHTTP Status Code: "+o.status
		     +"\nMessage: "+o.statusText);
	}
	
	// function called if Ajax request to inspect dataset succeded
	var handleGeometryIdSuccess = function(o) {

		// parse JSON response into object		
		var jsonResponse = eval('(' + o.responseText + ')');

		// populate geometry choices
		showGeometries(jsonResponse.geometries);

	}
	
	// function called if Ajax request to retrieve geometry sub-types succeded
	var handleGeometrySubCategorySuccess = function(o) {

		// parse JSON response into object		
		var jsonResponse = eval('(' + o.responseText + ')');

		/*
		// populate variables choices
		var options = new Array();
		for (var i = 0; i < jsonResponse.geometries.length; i++) {			
			options.push( [geometries[i][1], geometries[i][0]] );
		}
		showOptions("id_0-geometry_subcategory", options, [ "{{wizard.form.geometry_subcategory.value}}" ]);
		)*/

		showGeometrySubCategories(jsonResponse.geometries);
		
		// populate geometry IDs
		populateGeometryIds();

	}
	
	// function called if Ajax request to retrieve variables succeded
	var handleDatasetsSuccess = function(o) {
		
		// parse JSON response into object		
		var jsonData = eval('(' + o.responseText + ')');
		
		// populate 'long_name' widget
		populateDatasetOptions(WIDGET_VARIABLE, jsonData.response.long_name, [ jsonData.request.variable ])
		
		// populate 'time_frequency' widget
		populateDatasetOptions(WIDGET_TIME_FREQUENCY, jsonData.response.time_frequency, [ jsonData.request.time_frequency ])
		
		// populate 'dataset_category' widget
		populateDatasetOptions(WIDGET_DATASET_CATEGORY, jsonData.response.dataset_category, [ jsonData.request.dataset_category ])

		// populate 'dataset' widget
		populateDatasetOptions(WIDGET_DATASET, jsonData.response.dataset, [ jsonData.request.dataset ])

	}
	
	// function used to populate a single datasets widget
	function populateDatasetOptions(widget_id, options, selectedOptions) {
	
		// build (value, label) pairs, add null option
		var allOptions = new Array();
		if (options.length>1) {
			// prompt user to make a selection
			allOptions.push( NULL_SELECTION );
		}
		for (var i = 0; i < options.length; i++) {			
			allOptions.push( [options[i], options[i]] );
		}
		
		showOptions(widget_id, allOptions, selectedOptions);
		
	}
	
	// function called after Ajax request returns
	var ajaxDatasetsCallback = {
	  success: handleDatasetsSuccess,
	  failure: handleFailure,
	  cache: false,
	  timeout: 5000,
	  argument: [],
	};

	// function called after geometry Ajax request returns
	var geometrySubCategoryCallback = {
	  success: handleGeometrySubCategorySuccess,
	  failure: handleFailure,
	  cache: false,
	  timeout: 5000,
	  argument: [],
	};
	
	// function called after geometry Ajax request returns
	var geometryIdCallback = {
	  success: handleGeometryIdSuccess,
	  failure: handleFailure,
	  cache: false,
	  timeout: 5000,
	  argument: [],
	};
	
	function init() {
				
		//populateDatasets();
		populateVariables();
		populateGeometrySubCategories();
		//populateGeometryIds();
		
	}
	
	// reload all widgets every time
	window.onload = init;

		
</script>
       
<fieldset class="fieldset_box">
	<legend class="fieldset_legend">Data Selection</legend>	
	Please select a <i>dataset category</i>, a <i>dataset</i>, and a <i>variable</i>
	<br/>(when selecting a <i>dataset package</i>, a <i>variable</i> selection is not necessary).
	<p/>&nbsp;
	
	<table class="horizontalTable">
		<tr>
			<th>Select Data By</th>
			<td>{{ wizard.form.data_type }}
				<br/>&nbsp;<span class="error">{{ wizard.form.data_type.errors }}</span></td>
		</tr>
		<tr>
			<th>Long Name</th>
			<td>{{ wizard.form.variable }}
				<br/>&nbsp;<span class="error">{{ wizard.form.variable.errors }}</span></td>
		</tr>
		<tr>
			<th>Time Frequency</th>
			<td>{{ wizard.form.frequency }}
				<br/>&nbsp;<span class="error">{{ wizard.form.frequency.errors }}</span></td>
		</tr>
		<tr>
			<th>Dataset Category</th>
			<td>{{ wizard.form.dataset_category }}
				<br/>&nbsp;<span class="error">{{ wizard.form.dataset_category.errors }}</span></td>
		</tr>
		<tr>
			<th>Dataset</th>
			<td>{{ wizard.form.dataset }}
				<br/>&nbsp;<span class="error">{{ wizard.form.dataset.errors }}</span></td>
		</tr>

	</table>
</fieldset>

<fieldset class="fieldset_box">
	<legend class="fieldset_legend">Geo-Spatial Selection</legend>	
	Optionally, you may select either a <i>shape</i> geometry, a <i>bounding box</i>, or a <i>point</i>.
	<br/>If no selection is made,the full dataset geo-spatial extent will be processed.
	<p/>&nbsp;
	
	<table class="horizontalTable">
		<tr>
			<th>Geometry:</th>
			<td>
				Category: {{ wizard.form.geometry_category }}
				<br/>Sub-Category: {{ wizard.form.geometry_subcategory }}
				<br/><span class="error">{{ wizard.form.geometry_category.errors }}</span>
				<br/><span class="error">{{ wizard.form.geometry_subcategory.errors }}</span>
			</td>
			<td style="width:100%; text-align:left;"> 
			    Shape: {{ wizard.form.geometry_id }}
				<br/><span class="error">{{ wizard.form.geometry_id.errors }}</span>
			</td>
		</tr>
		<tr>
			<th nowrap="nowrap">Bounding Box:</th>
			<td colspan="3" nowrap="nowrap">
				Latitude min: {{ wizard.form.latmin }} max: {{ wizard.form.latmax }}
				Longitude min: {{ wizard.form.lonmin }} max: {{ wizard.form.lonmax }}
			</td>	
		</tr>
		<tr>
			<td></td>
			<td colspan="2"><span class="error">{{ wizard.form.latmin.errors }}</span>
							<span class="error">{{ wizard.form.latmax.errors }}</span>
							<span class="error">{{ wizard.form.lonmin.errors }}</span>
							<span class="error">{{ wizard.form.lonmax.errors }}</span>
			</td>
		</tr>
		<tr>
			<th>Point:</th>
			<td colspan="2">Latitude: {{ wizard.form.lat }}
							Longitude: {{ wizard.form.lon }}
				<br/><span class="error">{{ wizard.form.lat.errors }}</span>
				<br/><span class="error">{{ wizard.form.lon.errors }}</span>
			</td>	
		</tr>
		<tr>
			<td></td>
			<td colspan="2"><span class="error">{{ wizard.form.lat.errors }}</span>
							<span class="error">{{ wizard.form.lon.errors }}</span>
			</td>
		</tr>
		<tr>
			<th nowrap="nowrap">Aggregate Selection ?</th>
			<td colspan="2">{{ wizard.form.agg_selection }}
				&nbsp;If checked, the selection geometries will be aggregated prior to any spatial operations.
			     <br/><span class="error">{{ wizard.form.agg_selection.errors }}</span></td>
		</tr>
		
	</table>
</fieldset>

<fieldset class="fieldset_box">
	<legend class="fieldset_legend">Temporal Selection</legend>
	Optionally, you may specify a <i>time range</i> (i.e. a start and stop time), 
	and/or a <i>time selection</i> (one or more months, and/or one or more years).
	If both are specified, the <i>time range</i> must contain the <i>time selection</i>.
	<br/>If neither <i>time range</i> or <i>time selection</i> is specified,the full dataset temporal extent will be processed.
	<p/>&nbsp;
	
	<table class="horizontalTable">
		<tr>
			<th>Time Range: Start</th>
			<td>
				{{ wizard.form.datetime_start }} <b>Stop</b> {{ wizard.form.datetime_stop }} &nbsp; [Format: YYYY-MM-DD HH:MM:SS]
				<br/>
				<span class="error">{{ wizard.form.datetime_start.errors }} &nbsp; {{ wizard.form.datetime_stop.errors }}
			</td>
		</tr>
		<tr>
			<th>Time Selection: Months</th>
			<td nowrap="nowrap">
			{% for box in wizard.form.timeregion_month %}
				{{ box }}
			{% endfor %}
			</td>
		</tr>
		<tr>
			<th nowrap="nowrap">Time Selection: Years</th>
			<td>{{ wizard.form.timeregion_year }}
				&nbsp;[Format: YYYY, YYYY, ... or YYYY-YYYY]
			</td>
		</tr>
		<tr>
			<th></th>
			<td><span class="error">{{ wizard.form.timeregion_year.errors }}</span></td>
		</tr>
	</table>
</fieldset>